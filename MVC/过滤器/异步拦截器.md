# 拦截器

# Filter

```java
// 注意，这里必须开启异步支持asyncSupported = true，否则报错：Async support must be enabled on a servlet and for all filters involved in async request processing
@WebFilter(urlPatterns = "/*", asyncSupported = true)
public class HelloFilter extends OncePerRequestFilter {

  @Override
  protected void initFilterBean() throws ServletException {
    System.out.println("Filter初始化...");
  }

  @Override
  protected void doFilterInternal(
    HttpServletRequest request,
    HttpServletResponse response,
    FilterChain filterChain
  )
    throws ServletException, IOException {
    System.out.println(
      Thread.currentThread().getName() + "--->" + request.getRequestURI()
    );
    filterChain.doFilter(request, response);
  }
}
```

异步上下文，Filter 还是只会被执行一次拦截的。

# HandlerInterceptor

```java
public class HelloInterceptor implements HandlerInterceptor {

  @Override
  public boolean preHandle(
    HttpServletRequest request,
    HttpServletResponse response,
    Object handler
  )
    throws Exception {
    System.out.println(
      Thread.currentThread().getName() +
        "---preHandle-->" +
        request.getRequestURI()
    );
    return true;
  }

  @Override
  public void postHandle(
    HttpServletRequest request,
    HttpServletResponse response,
    Object handler,
    ModelAndView modelAndView
  )
    throws Exception {
    System.out.println(
      Thread.currentThread().getName() +
        "---postHandle-->" +
        request.getRequestURI()
    );
  }

  @Override
  public void afterCompletion(
    HttpServletRequest request,
    HttpServletResponse response,
    Object handler,
    Exception ex
  )
    throws Exception {
    System.out.println(
      Thread.currentThread().getName() +
        "---postHandle-->" +
        request.getRequestURI()
    );
  }
}

// 注册拦截器
@Configuration
@EnableWebMvc
public class AppConfig implements WebMvcConfigurer {

  @Override
  public void addInterceptors(InterceptorRegistry registry) {
    // /**拦截所有请求
      registry.addInterceptor(new HelloInterceptor()).addPathPatterns("/**");
  }
}
/**
http-apr-8080-exec-3--->/demowar_war/async/controller/hello
http-apr-8080-exec-3---preHandle-->/demowar_war/async/controller/hello

http-apr-8080-exec-3 主线程start
http-apr-8080-exec-3 主线程end
MvcAsync1 child thread start
MvcAsync1 child thread end

// 注意  child thread 处理结束后，再一次触发了preHandle=====
// 此处还要一个细节：这里面的线程既不是子线程，也不是上面的线程  而是新开了一个线程~~~
http-apr-8080-exec-5---preHandle-->/demowar_war/async/controller/hello
http-apr-8080-exec-5---postHandle-->/demowar_war/async/controller/hello
http-apr-8080-exec-5---afterCompletion-->/demowar_war/async/controller/hello
*/
```

如果我们就是普通的 Spring MVC 的拦截器，preHandler 会执行两次，这也符合我们上面分析的处理步骤。所以我们在书写 preHandler 的时候，一定要特别的注意，要让 preHandler 即使执行多次，也不要受到影响（幂等）

# 异步拦截器

Spring MVC 给提供了异步拦截器，能让我们更深入的参与进去异步 request 的生命周期里面去。其中最为常用的为：AsyncHandlerInterceptor：

```java
public class AsyncHelloInterceptor implements AsyncHandlerInterceptor {

  // 这是Spring3.2提供的方法，专门拦截异步请求的方式
  @Override
  public void afterConcurrentHandlingStarted(
    HttpServletRequest request,
    HttpServletResponse response,
    Object handler
  )
    throws Exception {
    System.out.println(
      Thread.currentThread().getName() +
        "---afterConcurrentHandlingStarted-->" +
        request.getRequestURI()
    );
  }

  @Override
  public boolean preHandle(
    HttpServletRequest request,
    HttpServletResponse response,
    Object handler
  )
    throws Exception {
    System.out.println(
      Thread.currentThread().getName() +
        "---preHandle-->" +
        request.getRequestURI()
    );
    return true;
  }

  @Override
  public void postHandle(
    HttpServletRequest request,
    HttpServletResponse response,
    Object handler,
    ModelAndView modelAndView
  )
    throws Exception {
    System.out.println(
      Thread.currentThread().getName() +
        "---postHandle-->" +
        request.getRequestURI()
    );
  }

  @Override
  public void afterCompletion(
    HttpServletRequest request,
    HttpServletResponse response,
    Object handler,
    Exception ex
  )
    throws Exception {
    System.out.println(
      Thread.currentThread().getName() +
        "---afterCompletion-->" +
        request.getRequestURI()
    );
  }
}
```

AsyncHandlerInterceptor 提供了一个 afterConcurrentHandlingStarted()方法, 这个方法会在 Controller 方法异步执行时开始执行, 而 Interceptor 的 postHandle 方法则是需要等到 Controller 的异步执行完才能执行。比如我们用 DeferredResult 的话，afterConcurrentHandlingStarted 是在 return 的之后执行，而 postHandle()是执行.setResult()之后执行。

需要说明的是：如果我们不是异步请求，afterConcurrentHandlingStarted 是不会执行的。所以我们可以把它当做加强版的 HandlerInterceptor 来用。平时我们若要使用拦截器，建议使用它。同样可以注册 CallableProcessingInterceptor 或者一个 DeferredResultProcessingInterceptor 用于更深度的集成异步 request 的生命周期：

```java
@Override
public void configureAsyncSupport(AsyncSupportConfigurer configurer) {
    // 注册异步的拦截器、默认的超时时间、任务处理器TaskExecutor等等
    //configurer.registerCallableInterceptors();
    //configurer.registerDeferredResultInterceptors();
    //configurer.setDefaultTimeout();
    //configurer.setTaskExecutor();
}
```
