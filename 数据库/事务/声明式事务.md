# Declarative Transaction Management（声明式事务管理）

声明式事务的首要操作就是添加 `@EnableTransactionManagement` 到配置类中，然后在需要实现事务控制的类上添加 `@Transactional` 注解。声明式事务主要是基于 AOP 代理实现，并且由定义在 XML 或者注解中的元数据所驱动。一个 AOP 和事务元信息的组合会使用 `TransactionIntercetor` 与`PlatformTransactionManager` 的组合来实现在方法调用前后的事务控制。

首先我们定义一个接口及其实现：

```java
// the service interface that we want to make transactional
package x.y.service;

@Transactional
public interface FooService {
    Foo getFoo(String fooName);
    Foo getFoo(String fooName, String barName);
    void insertFoo(Foo foo);
    void updateFoo(Foo foo);
}

//在实现的类中也可以设置对于父类或者父接口的Transactional的复写
@Transactional(readOnly = true)
public class DefaultFooService implements FooService {

    public Foo getFoo(String fooName) {
        // do something
    }

    ...

    // these settings have precedence for this method
    @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
    public void updateFoo(Foo foo) {
        // do something
    }
}
```

这里假设在 FooService 的 `get*` 方法中执行只读事务策略，即如果发现有写入或者删除直接回滚，而 insertFoo 与 updateFoo 方法则运行在读写策略的事务上下文中。基本的 XML 中的配置如下：

```xml
<!-- from the file 'context.xml' -->
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd
  http://www.springframework.org/schema/tx
  http://www.springframework.org/schema/tx/spring-tx.xsd
  http://www.springframework.org/schema/aop
  http://www.springframework.org/schema/aop/spring-aop.xsd">

  <!-- this is the service object that we want to make transactional -->
  <bean id="fooService" class="x.y.service.DefaultFooService"/>

 <!--通用事务管理器-->
  <bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
  <property name="dataSource" ref="dataSource"/>
  </bean>

  <!-- 指定事务策略,声明一个通知，用以指出要管理哪些事务方法及如何管理 -->
  <tx:advice id="txAdvice" transaction-manager="txManager">
  <!-- the transactional semantics... -->
  <tx:attributes>
  <!-- all methods starting with 'get' are read-only -->
  <tx:method name="get*" read-only="true"/>
  <!-- other methods use the default transaction settings (see below) -->
  <tx:method name="*"/>
  </tx:attributes>
  </tx:advice>

  <!-- 声明一个config，用以将事务策略和业务类关联起来-->
  <aop:config>
  <aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>
  <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>
  </aop:config>

  <!-- don't forget the DataSource -->
  <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
  <property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
  <property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
  <property name="username" value="scott"/>
  <property name="password" value="tiger"/>
  </bean>

  <!-- other <bean/> definitions here -->
</beans>
```

这里 tx:method 的详细配置项如下：

| 属性            | 说明                                                                                                                                                        |
| --------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name            | 方法名的匹配模式，通知根据该模式寻找匹配的方法。该属性可以使用 asterisk (\*)通配符                                                                          |
| propagation     | 设定事务定义所用的传播级别                                                                                                                                  |
| isolation       | 设定事务的隔离级别                                                                                                                                          |
| timeout         | 指定事务的超时(单位为秒)                                                                                                                                    |
| read-only       | 该属性为 true 指示事务是只读的(典型地，对于只执行查询的事务你会将该属性设为 true，如果出现了更新、插入或是删除语句时只读事务就会失败)                       |
| no-rollback-for | 以逗号分隔的异常类的列表，目标方法可以抛出 这些异常而不会导致通知执行回滚                                                                                   |
| rollback-for    | 以逗号分隔的异常类的列表，当目标方法抛出这些 异常时会导致通知执行回滚。默认情况下，该列表为空，因此不在 no-rollback-for 列表中的任何运行 时异常都会导致回滚 |

如果你希望针对所有的 Service 类都包裹在事务中，则：

```xml
<aop:config>
    <aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>
</aop:config>
```

## Multiple TransactionalManager

```java
public class TransactionalService {
    @Transactional("order")
    public void setSomething(String name) { ... }

    @Transactional("account")
    public void doSomething() { ... }
}
```

```xml
<tx:annotation-driven/>
    <bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        ...
        <qualifier value="order"/>
    </bean>

    <bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        ...
        <qualifier value="account"/>
    </bean>
```

## 事务回滚

一般来说，声明式事务都是利用抛出异常进行回滚，在`tx:advice`的配置中，也可以对不同的方法指定不同的回滚类：

```xml
<tx:advice id="txAdvice" transaction-manager="txManager">
    <tx:attributes>
    <tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>
    <tx:method name="*"/>
    </tx:attributes>
</tx:advice><tx:advice id="txAdvice">
    <tx:attributes>
    <tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>
    <tx:method name="*"/>
    </tx:attributes>
</tx:advice><tx:advice id="txAdvice">
    <tx:attributes>
    <tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>
    </tx:attributes>
</tx:advice>
```

同时也可以在代码中指明特定的回滚规则，譬如：

```java
public void resolvePosition() {
    try {
        // some business logic...
    } catch (NoProductInStockException ex) {
        // trigger rollback programmatically
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}
```
